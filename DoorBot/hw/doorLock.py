"""
This daemon waits for a message fron redis on the 'doorlock'
channel and energizes or deenergizes the lock solenoid

It will automatically de-energize the relay after 'lockOpenTime',
which is in the config file.

If a 'stop' message (generated by sigterm or sigint) is send, the program will exit
"""
import redis
import pigpio
from DoorBot.constants import * 
import DoorBot.Config as Config
import redis
import signal
import threading
import requests
from DoorBot.redisGet import redisGet

timing = Config.get('timing')
gpio = Config.get('gpio')
DEBUG = Config.get('DEBUG')
redis_cli = redis.Redis()
pubsub = redis_cli.pubsub()
pubsub.subscribe(DOOR_LOCK_CHANNEL)


pi = pigpio.pi()
lock = gpio['doorlock']

pi.set_mode(lock, pigpio.OUTPUT)
pi.set_pull_up_down(lock, pigpio.PUD_DOWN)
pi.write(lock,pigpio.LOW)

def updateUI():
    result = requests.get('http://127.0.0.1:5000/api/doorChange')
    if result.status_code != 200:
        print("wierd return in update UI")

def unlockDoor():
    if DEBUG:
        print("open lock request")
    redis_cli.set(LOCK_STATE, 'unlocked')
    pi.write(lock,pigpio.HIGH)
    updateUI()

def lockDoor():
    if DEBUG:
        print("close lock request")
    redis_cli.set(LOCK_STATE, 'locked')
    pi.write(lock,pigpio.LOW)
    updateUI()

def signalHandler(sig, frame):
    if DEBUG:
        print(f"stop requested via sigterm or sigint {sig}")
    redis_cli.publish(DOOR_LOCK_CHANNEL,'stop')

def triggerDoorLock():
    if DEBUG:
        print("door lock triggered")
    redis_cli.publish(DOOR_LOCK_CHANNEL, 'lock')
 


def main():
    """
    use redis pubsub to react to lock state change request events.

    valid data:
        'unlock' - 
            if lock is not already unlocked, unlock it and set state to unlocked
        'lock' -
            if lock is not already locked, lock it and set state to locked
        'stop'
            terminate the daemon cleanly
    """

    signal.signal(signal.SIGINT, signalHandler)
    signal.signal(signal.SIGTERM, signalHandler)
    relock = None
    for message in pubsub.listen():
        if DEBUG:
            print(message)
        if message['type'] == 'subscribe':
            continue
        elif message['type'] == 'message':
            data = message['data'].decode("utf-8")
            lockState = redisGet(LOCK_STATE)
            if data == 'unlock' and lockState != 'unlocked':
                # open the lock and start a timer to close it using threading
                unlockDoor()
                delay = float(timing['lockOpenTime'])
                if DEBUG:
                    print(f"Delay is {delay}")
                relock = threading.Timer(delay, triggerDoorLock)
                relock.start()
            elif data == 'lock' and lockState != 'locked':
                if relock != None and relock.is_alive():
                    relock.cancel()
                lockDoor()
            elif data == 'stop':
                break
            else:
                print("invalid message data")
                result = requests.get('http://127.0.0.1:5000/api/doorChange')
                if result.status_code != 200:
                    print("wierd return in DoorLock")

    print("Lock daemon stopping")  
    lockDoor()
    redis_cli.set(LOCK_STATE, 'locked')
    if relock != None and relock.is_alive():
        relock.cancel()
    pi.stop() 


if __name__ == '__main__': 
    if DEBUG:
        print("starting lockLock daemon")
        main()
    else:
        print("run as a daemon")








